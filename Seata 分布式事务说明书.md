# Seata 分布式事务说明书

本文记录分布式事务产生的背景、Seata 的使用步骤以及基本运行原理，适用于 Spring Cloud + Nacos + Seata 的微服务架构。

------

## 一、为什么需要分布式事务

在单体架构中，一个业务流程通常只涉及一个数据库，例如：
 用户支付 → 扣余额 → 扣库存 → 生成订单
 这些步骤全部在同一个数据库中执行，一个本地事务即可保证失败即回滚，实现 ACID（原子性、一致性、隔离性、持久性）。

在微服务架构中，情况发生变化：

- 用户服务管理账户余额
- 商品服务管理库存
- 订单服务负责下单
   每个服务有独立数据库。

当订单服务调用用户服务扣除余额，再调用库存服务扣减库存时，如果余额不足，本地数据库会回滚；但库存服务已经执行扣减，不会自动撤销，系统产生数据不一致。

**分布式事务** 就是用来解决不同服务、不同数据库之间操作不一致的问题。
 **Seata** 是目前最常用的分布式事务协调器。

------

## 二、Seata 的使用步骤

### 1. 准备 Seata 服务端（TC：事务协调者）

下载版本（示例为 2.5.0）。

进入：

```
seata-server/conf
```

修改 `application.yml`，使 Seata 以 **Nacos 方式注册**。
 注意以下关键配置需和微服务保持一致：

- namespace（建议为空字符串""，即默认 public）
- group（如 DEFAULT_GROUP）
- cluster（如 SH）
- application（自定义，如 seata-server）

配置完成后，进入 `bin/` 目录运行启动脚本。
 启动成功后，可以在 Nacos 服务列表中看到 `seata-server`。

<img src="https://imgheybox1.max-c.com/web/bbs/2025/11/13/31b243b06e6e41328a915bf4b6b9186b.png" alt="img" style="zoom:33%;" />



------

### 2. 在微服务中引入 Seata 依赖

每个需要参与全局事务的服务都需要增加 Seata 相关依赖（参考图示）。

![img](https://imgheybox1.max-c.com/web/bbs/2025/11/13/9b77909e446e6581a8a77803d32f8f65.png)

------

### 3. 配置微服务使用 Seata

在各自的 `application.yml` 中配置 Seata 客户端信息，包括：

- 注册中心信息
- 配置中心信息
- 所属 group
- 所属 cluster

这些内容必须与步骤 1 中的 Seata 服务端配置一致。
 如果不确定，可直接在 Nacos 中查看 `seata-tc-server` 的实时配置。

<img src="https://imgheybox1.max-c.com/web/bbs/2025/11/13/c525ae50e9f721c318c28e6cbbdfc262.png" alt="img" style="zoom: 50%;" />



------

### 4. 使用全局事务注解

在业务方法中加入：

```
@GlobalTransactional
public void xxx() { ... }
```

只需要添加在调用链最外层的方法（通常是订单服务的业务方法）。
 Feign 调用下游服务时，将自动纳入同一个全局事务。

![img](https://imgheybox1.max-c.com/web/bbs/2025/11/13/17e93cbee4773a9aa863b70f2aee8093.png)



------

### 5. 准备数据库表

所有参与分布式事务的数据库（如 user、order）需要添加 Seata 官方脚本：

```
seata-server/script/server/db
```

这些脚本用于创建：

- `undo_log`（用于 AT 分支回滚）
- 以及服务器端需要的相关表结构

未添加此脚本将导致 AT 模式不可用。

------

## 三、Seata 的原理概述

Seata 共支持四种模式，本说明重点讲解 AT 与 XA 区别。

------

### AT 模式（最常用的自动补偿模式）

AT 由两阶段组成，但具有“**本地事务先提交，失败由 undo_log 自动回滚**”的特性。

#### （1）第一阶段：执行业务并记录快照

在执行更新语句前，Seata 自动完成：

1. 记录 before image（修改前记录）
2. 在 `lock_table` 中锁住这条数据
3. 执行 SQL（扣减库存等）
4. 记录 after image（修改后记录），写入 `undo_log`
5. 提交本地事务（已生效，但未释放全局锁）

#### （2）并发场景：事务 B 尝试修改同一行

事务 B 若想更新同一条库存记录，需要获取 **global lock**。
 由于 A 持有锁，B 会阻塞或重试，避免出现脏写。

#### （3）第二阶段：全局提交或回滚

- **提交时**：清除 undo_log + 释放全局锁
- **回滚时**：根据 undo_log 恢复数据 + 释放全局锁

此模式无需 XA 那样锁住资源长时间等待，因此性能更优。

------

### XA 模式（强一致但性能较差）

XA 的特点是：

- 在全局事务完成之前，数据库资源一直处于锁定状态
- 全局事务结束前，分支事务不能提交
- 一旦需要回滚，必须回滚数据库，再释放资源

对比 AT：

- **XA 是先判断后提交**
- **AT 是先提交再补偿**

因此 AT 更适合高并发业务场景。


# Sentinel 入门说明书

Sentinel 是微服务体系里的“流量守门员”。它的任务在于监控调用链路，识别异常流量，并在必要时及时“挡住危险”，让系统在高压下依旧能稳稳站住，而不是出现链式反应的雪崩。

## 一、为什么需要 Sentinel

在多层调用的微服务架构中，每个服务都有自己的承载上限。当一个下游服务突然变慢或宕机时，上游服务发出的请求会堆积，线程资源被占满，继而影响其他正常调用，最终整条链路都可能失效。

典型场景：
 服务 1、2、3、4 → 调用服务 A
 服务 A → 调用 B、C、D
 如果 B 卡住，A 针对 B 的请求堆积，会占掉线程，导致 A 无法正常调用 C、D，最后 A、B、C、D 整体不可用，甚至继续向上传导。

Sentinel 通过以下几种方式减轻风险：限流、熔断降级、隔离、超时控制等。目标是让系统在压力和异常面前仍能保持可用性，不至于集体崩盘。

常见的四种思路：

- 给调用设置超时时间，避免请求无限等待。
- 拆分服务以降低耦合（把 A 对 B/C/D 的调用隔离开）。
- 熔断，让上游尽快知道下游不可用并停止发送请求。
- 限流，让过载流量不要一股脑挤进来。

## 二、怎么实现 Sentinel

1. 启动 Sentinel 控制台。官方提供一个独立的 jar 包，直接运行即可。默认监听 8080 端口，登录后就能看到流量监控面板。

2. 在微服务中引入依赖。通常需要 sentinel-core 和 sentinel-transport。

   <img src="https://imgheybox1.max-c.com/web/bbs/2025/11/14/ffc8c5d8a81ec3f9b84427f8c17f9057.png" alt="img" style="zoom:50%;" />

   

3. 在服务的 yml 中添加 Sentinel 相关配置，包括 dashboard 地址。Nacos 的部分原本就在我的配置里，只需要注意不要混淆。

   <img src="https://imgheybox1.max-c.com/web/bbs/2025/11/14/abbba39c4ac7bd6f76cda4aa73142d0a.png" alt="img" style="zoom:50%;" />

   

4. 添加注解开启资源监控。
    有两种方式：

   放在 Controller：
    `@SentinelResource("host")`

   或者放在服务接口上：

   <img src="https://imgheybox1.max-c.com/web/bbs/2025/11/14/a4b911632e0e15b8dfdf241a250f67b3.png" alt="img" style="zoom:50%;" />

   

    `value` 用来标记资源名称，这个名字会在 Sentinel 控制台里配置限流规则。
    `blockHandler` 指定一个方法作为“限流后的兜底”，当请求被挡下时这个方法会执行。

到这里，一个具备基本限流能力的微服务就跑起来了。



我们先来看限流

限流有两种:***<u>QPS</u>***和***并发线程数***;我可以理解为预防针功能.

### **QPS**:

我设置某个接口的 QPS 阈值，比如 50 QPS。当接口被调用超过 50 次/秒，Sentinel 就会生效限制(见下文)，保护下游服务不被压垮。Sentinel 生效情况看我们的选择

***流控模式----直接***:只看自己这个接口的请求数，直接限制请求数。

***流控模式---关联**:*某个接口的请求数受另一个接口的流控规则限制（假设给接口A设置规则,顺便关联B.此时B的访问数越多A的限流就越强）.我们可以类比资源只有那么多,有些接口(B)经常会被大量访问,有些接口(A)很少访问.此时,为了防止B接口暴毙只能牺牲A接口的资源了

***流控模式---链路*:**接口在调用链中累积流量，比如 A 调用 B，B 的流量统计只算从 A 来的请求.就假设我给接口A写好这个规则并连接接口B,然后接口A被黑客劫持,也不偷我的信息就是不停的调用接口A来烦我的接口B.此时通过这个功能会直接会给接口A停了

***流控效果---快速失败***:超过 QPS 的请求直接返回错误，不处理。

***流控效果---warm Up***:系统慢慢加速处理请求，防止刚启动就被高峰打垮.

***流控效果---排队等待***:超过阈值的请求排队等待处理，而不是直接失败。

### **并发线程数**:

举个例子:一个餐厅(接口)，每个厨师一次只能做一份汉堡。如果同时来了 5 个顾客(请求)，而只有 2 个厨师在工作(设定的阈值)，多出的 3 个顾客得等或者被拒绝。这里的“厨师数”就是并发线程数。

流控模式和QPS一样,没有流控效果





# 接下来是熔断/降级(如果说限流是预防针,那么熔断/降级就是开始治病)

熔断有三种情况设置熔断

### 1.**慢调用比例:**<img src="E:\学习记录\慢调用比例.png" style="zoom: 50%;" />

当 **1秒内** (统计时常)至少有 5 个请求(最小请求数)，且超过 40% 的请求(比例阈值)响应时间超过 500ms(最大RT) 时，该资源会被熔断。

熔断生效后 **5 秒** 内(熔断时长)，所有请求将直接走降级逻辑(所有请求为资源名的都会被丢弃)



### 2.**异常比例:**<img src="E:\学习记录\异常比例.png" style="zoom: 50%;" />

这个需要我们手动抛出异常,基本和慢调用类似.当1秒内发生5次请求并且(错误数/5)超过比例阈值就会熔断



### 3.**异常数:**<img src="E:\学习记录\异常数.png" style="zoom:50%;" />

当1秒内出现5次请求并且异常数量到达阈值后会熔断





# 最后是热点规则

想象一家奶茶店，卖各种口味。

- 大部分人随便点：红豆奶茶、抹茶奶茶、香芋奶茶……
- 就某一个味道爆红，比如“杨枝甘露”。

于是老板发现：杨枝甘露太火了，原料快撑不住，要单独限流。

所以：

- 整个店不限流
- 杨枝甘露这个口味要单独限流（比如每秒只能卖 5 杯）

这就是 **热点规则**。

如图所示<img src="E:\学习记录\热点.png" style="zoom:50%;" />

对方法(资源名)的第 1 个参数（参数索引 0）来说，如果它的值是 2(参考值)，在 **最近 10 秒** 内请求次数超过 **每秒 5 次**（单机限流阈值），就会触发热点参数限流，超过的请求会被拒绝或者走降级逻辑。
 这个规则只在单机生效，不考虑集群。





## ***特别提醒:RabbitMQ和Sentinel一样需要我们主动调用测试接口才可以在控制台上看到数据.还有记得检测时长要设置久一点,别设置成检测1s内接口出现错误的比例/数量.毕竟手速跟不上***





